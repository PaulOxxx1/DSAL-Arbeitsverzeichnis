\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\renewcommand{\thispagestyle}[1]{} % damit Titelseite Kopfzeile bekommt
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\lstset{language=C++, numbers=left, frame=single,}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\usepackage{tikz}
\usepackage{multicol}

\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkGroup\\\hmwkTitle}
\rhead{\hmwkAuthorName}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Aufgabe \arabic{#1} wird auf nächster Seite fortgesetzt\ldots}\nobreak{}
    \nobreak\extramarks{Aufgabe \arabic{#1} (fortgesetzt)}{Aufgabe \arabic{#1} wird auf nächster Seite fortgesetzt\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Aufgabe \arabic{#1} (fortgesetzt)}{Aufgabe \arabic{#1} wird auf nächster Seite fortgesetzt\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Aufgabe \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Aufgabe \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%

\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Aufgabe \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\date{15.06.2018}
\newcommand{\hmwkTitle}{Übungsblatt\ \#8}
\newcommand{\hmwkGroup}{Übungsgruppe 16}
\newcommand{\hmwkDueDate}{21. Juni 2018}
\newcommand{\hmwkClass}{Datenstrukturen und Algorithmen}
\newcommand{\hmwkAuthorName}{\textbf{Finn Hess (378104), Jan Knichel (377779), Paul Orschau (381085)}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Abgabe\ am\ \hmwkDueDate\ }\\
    \vspace{3in}
}

\author{\hmwkAuthorName}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\loesung}{\textbf{\large Lösung}}

% Parts
\newcommand{\teil}[1]{\vspace{15pt}\textbf{Teil #1}}


%
% Start of Document
%

\begin{document}

  \maketitle

  \pagebreak

  \begin{homeworkProblem}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & 4 & 5 & 5 & 0 & 2 \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      1 & 1 & 3 & 4 & 5 & 7 & 8 & \\
      \hline
       &  &  &  &  &  &  &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & 4 & 5 & 5 & 0 & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      1 & 1 & 2 & 4 & 5 & 7 & 8 & \\
      \hline
       &  & 2 &  &  &  &  &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & 4 & 5 & 5 & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 2 & 4 & 5 & 7 & 8 & \\
      \hline
      0 &  & 2 &  &  &  &  &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & 4 & 5 & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 2 & 4 & 5 & 6 & 8 & \\
      \hline
      0 &  & 2 &  &  &  & 5 &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & 4 & * & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 2 & 4 & 5 & 5 & 8 & \\
      \hline
      0 &  & 2 &  &  & 5 & 5 &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & 2 & * & * & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 2 & 4 & 4 & 5 & 8 & \\
      \hline
      0 &  & 2 &  & 4 & 5 & 5 &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & 6 & * & * & * & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 1 & 4 & 4 & 5 & 8 & \\
      \hline
      0 & 2 & 2 &  & 4 & 5 & 5 &  \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      3 & * & * & * & * & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 1 & 4 & 4 & 5 & 7 & \\
      \hline
      0 & 2 & 2 &  & 4 & 5 & 5 & 6 \\
      \hline
    \end{array}$
    
    \vspace{0.2in}
    
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|}
      \hline  
      * & * & * & * & * & * & * & * \\
      \hline
      1 & 0 & 2 & 1 & 1 & 2 & 1 & \\
      \hline
      0 & 1 & 1 & 3 & 4 & 5 & 7 & \\
      \hline
      0 & 2 & 2 & 3 & 4 & 5 & 5 & 6 \\
      \hline
    \end{array}$
    
  \end{homeworkProblem}
  
  \begin{homeworkProblem}
    
    \teil{c)}
    
    Eine erfolglose Suche wird nie terminieren, da immer wieder eine zufällige Slotnummer ermittelt wird, der gesuchte Schlüssel aber nie gefunden wird. Daher ist die Average-Case-Komplexität nicht ermittelbar bzw. in $\Theta (\infty)$.
    
    \teil{d)}
    
    \begin{itemize}
      \item \textbf{Einfache Berechenbarkeit:} Eine zufällige Slotnummer lässt sich effizient ermitteln, daher hat randomisiertes Hashing eine einfache Berechenbarkeit. 
      \item \textbf{Surjektivität:} Früher oder später wird jeder Slot gefüllt sein, denn bei jedem Einfügevorgang hat jeder Slot die Chance gefüllt zu werden. Je voller das Array, desto größer die Chance, bis schließlich nur noch ein freies Feld übrig ist, welches dann sicher beim nächsten Einfügen gefüllt werden muss.
      \item \textbf{Gleichverteilung auf alle Indizes:} Durch die zufällige Wahl der Slotnummer werden die Schlüssel optimal verteilt.
      \item \textbf{Möglichst breite Verteilung ähnlicher Schlüssel auf die Hashtabelle:} Da die gewählte Slotnummer in keiner Weise vom Schlüssel abhängt, ist sichergestellt, dass ähnliche Schlüssel genau so zufällig verteilt werden, wie völlig verschiedene Schlüssel. Die Verteilung ist also gut.
    \end{itemize}
    
    Zusätzliches Kriterium: \textbf{Terminierung}
    
    Der Algorithmus braucht mit zunehmendem Füllgrad immer länger, um neue Elemente einzufügen, weil er zum Beispiel nur eine Chance von $\frac{1}{m}$  hat, den letzten freien Slot auf Anhieb zu füllen. Abhängig von der Größe der Hashtabelle kann der letzte Einfügevorgang also ewig dauern! Ist die Tabelle voll, so terminiert der Algorithmus beim nächsten Einfügen gar nicht, was sehr schlecht ist.
    
  \end{homeworkProblem}
    
  \begin{homeworkProblem}[3]
    
    Funktion \texttt{f}:
    
    \begin{itemize}
      \item \textbf{Einfache Berechenbarkeit:} Vergleichsweise schlecht, da Divisionen "teuerer" sind als z.B. Modulorechnung oder Multiplikationen.
      \item \textbf{Surjektivität:} Sehr schlecht, denn es werden sehr viele  Werte nie getroffen. Die Wertemenge ist $\{0,1,2,3,5,10\}$, also werden die Felder $\{4,6,7,8,9\}$ nie belegt!
      \item \textbf{Gleichverteilung auf alle Indizes:} Sehr schlecht, nicht nur aufgrund der Argumente zur Sujektivität, sondern auch weil alle Zahlen $k>10$ auf die $0$ abgebildet werden.
      \item \textbf{Möglichst breite Verteilung ähnlicher Schlüssel auf die Hashtabelle:} Diese Eigenschaft mag für die ersten beiden Zahlen $k=1$ und $k=2$ noch gegeben sein, aber schon ab $k=3$ liegen alle Werte entweder direkt nebeneinander oder sogar auf dem selben Feld, siehe oben.
    \end{itemize}
    
    Funktion \texttt{g}:
    
    \begin{itemize}
      \item \textbf{Einfache Berechenbarkeit:} Die diskrete Exponentialfunktion ist auch für große Exponenten effizient berechenbar.
      \item \textbf{Surjektivität:} Nicht surjektiv, da die Funktion niemals auf die $0$ abbilden wird. Beweis: Alle Zahlen, die $2^x$ für steigende $x$ erzeugen kann, haben offensichtlich stets eine Primfaktorzerlegung in der nur 2er vorkommen, insbesondere ist keine der Zahlen durch $101$ teilbar. Dies ist aber Vorraussetzung dafür, dass $a \mod 101 = 0$ für ein $a:=2^x$ gelten kann. 
      \item \textbf{Gleichverteilung auf alle Indizes:} Wir haben keine Begründung gefunden, gehen aber davon aus, dass die Indizes nicht gleichmäßig verteilt werden.
      \item \textbf{Möglichst breite Verteilung ähnlicher Schlüssel auf die Hashtabelle:} Diese Eigenschaft ist gegeben, denn wenn man $x$ um eins erhöht, ändert sich die Zahl, die modulo genommen wird, dramatisch.
    \end{itemize}
    
    Funktion \texttt{h}: Entspricht Divisionsmethode aus der Vorlesung mit $m=11$.
    
    \begin{itemize}
      \item \textbf{Einfache Berechenbarkeit:} Modulo ist sehr effizient berechenbar.
      \item \textbf{Surjektivität:} Surjektiv, da bereits die ersten $10$ Werte alle Indizes belegen.
      \item \textbf{Gleichverteilung auf alle Indizes:} Wenn jeder zulässige Wert einmal abgespeichert werden würde, enhielte jeder Index im Wertebereich etwa 9 Schlüssel, und auch für größere Ausgangsmengen bleiben die Schlüssel gleichmäßig verteilt, da immer von einem Wert zum nächsten gesprungen wird.
      \item \textbf{Möglichst breite Verteilung ähnlicher Schlüssel auf die Hashtabelle:} Sehr schlecht, da zwei benachbarte Schlüssel stets in benachbarten Indizes landen, außer wenn der letzte Listenplatz getroffen wurde.
    \end{itemize}
    
    Funktion \texttt{i}: 
    
    \begin{itemize}
      \item \textbf{Einfache Berechenbarkeit:} Modulo ist zwar sehr effizient berechenbar, aber durch die Division durch 2 ist die Funktion etwas schwerer zu berechnen.
      \item \textbf{Surjektivität:} Surjektiv, da bereits die ersten $100$ Werte alle Indizes belegen.
      \item \textbf{Gleichverteilung auf alle Indizes:} Die Schlüssel sind gleichmäßig verteilt, da immer von einem Wert zum nächsten gesprungen wird. Auch wenn eine zufällige Folge von natürlichen Zahlen abgespeichert wird, sind die resultierenden Indizes zufällig verteilt.
      \item \textbf{Möglichst breite Verteilung ähnlicher Schlüssel auf die Hashtabelle:} Sehr schlecht, da zwei benachbarte Schlüssel stets in benachbarten Indizes landen, außer wenn der letzte Listenplatz getroffen wurde. Bei dieser Funktion landen sogar immer zwei Zahlen hintereinander auf dem selben Index, da durch $2$ geteilt und dann abgerundet wird!
    \end{itemize}
    
  \end{homeworkProblem}
  
  \begin{homeworkProblem}  
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
      \texttt{a[0]} & \texttt{a[1]} & \texttt{a[2]} & \texttt{a[3]} & \texttt{a[4]} & \texttt{a[5]} & \texttt{a[6]} & \texttt{a[7]} & \texttt{a[8]} & \texttt{a[9]} & \texttt{a[10]} \\
      \hline
      5 &  &  &  &  &  &  &  &  &  & \\
      \hline
      5 &  & 21 &  &  &  &  &  &  &  & \\
      \hline
      5 &  & 21 & 23 &  &  &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 23 &  &  &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 23 & 11 &  &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 23 & 11 & 7 &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 23 & 11 & 7 & 1 &  &  &  & \\
      \hline
    \end{array}$  
  
  \end{homeworkProblem}

  \begin{homeworkProblem}
    $\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
      \texttt{a[0]} & \texttt{a[1]} & \texttt{a[2]} & \texttt{a[3]} & \texttt{a[4]} & \texttt{a[5]} & \texttt{a[6]} & \texttt{a[7]} & \texttt{a[8]} & \texttt{a[9]} & \texttt{a[10]} \\
      \hline
      5 &  &  &  &  &  &  &  &  &  & \\
      \hline
      5 &  & 21 &  &  &  &  &  &  &  & \\
      \hline
      5 &  & 21 &  &  & 23 &  &  &  &  & \\
      \hline
      5 & 17 & 21 &  &  & 23 &  &  &  &  & \\
      \hline
      5 & 17 & 21 &  & 11 & 23 &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 7 & 11 & 23 &  &  &  &  & \\
      \hline
      5 & 17 & 21 & 7 & 11 & 23 &  &  & 1 &  & \\
      \hline
    \end{array}$
  
  \end{homeworkProblem}

  \begin{homeworkProblem}[6]
    
    \teil{a)}
    
    \lstinputlisting{Code/6_a.cpp}

    \teil{b)}
    
    \lstinputlisting{Code/6_b.cpp}

    \pagebreak

    \teil{c)}
    
    \lstinputlisting{Code/6_c.cpp}

    \teil{d)}
    
    \lstinputlisting{Code/6_d.cpp}

    \teil{e)}
    
    \lstinputlisting{Code/6_e.cpp}

  \end{homeworkProblem}
  
\end{document}